<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>继承的几种方式 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="继承实现方式先写一个父类Demo// 定义一个动物类 function Animal (name) {   // 属性   this.name = name || &amp;apos;Animal&amp;apos;;   this.age = age;   // 实例方法   this.sleep = function(){     console.log(this.name + &amp;apos;正在睡觉！&amp;apo">
<meta name="keywords" content="继承">
<meta property="og:type" content="article">
<meta property="og:title" content="继承的几种方式">
<meta property="og:url" content="http://yoursite.com/2019/03/13/JS继承的几种方式/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="继承实现方式先写一个父类Demo// 定义一个动物类 function Animal (name) {   // 属性   this.name = name || &amp;apos;Animal&amp;apos;;   this.age = age;   // 实例方法   this.sleep = function(){     console.log(this.name + &amp;apos;正在睡觉！&amp;apo">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-13T03:41:47.865Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="继承的几种方式">
<meta name="twitter:description" content="继承实现方式先写一个父类Demo// 定义一个动物类 function Animal (name) {   // 属性   this.name = name || &amp;apos;Animal&amp;apos;;   this.age = age;   // 实例方法   this.sleep = function(){     console.log(this.name + &amp;apos;正在睡觉！&amp;apo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JS继承的几种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/JS继承的几种方式/" class="article-date">
  <time datetime="2019-03-13T03:41:47.865Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/构造函数继承/">构造函数继承</a>►<a class="article-category-link" href="/categories/构造函数继承/原型继承/">原型继承</a>►<a class="article-category-link" href="/categories/构造函数继承/原型继承/构造-原型继承/">构造+原型继承</a>►<a class="article-category-link" href="/categories/构造函数继承/原型继承/构造-原型继承/copy/">copy</a>►<a class="article-category-link" href="/categories/构造函数继承/原型继承/构造-原型继承/copy/extends/">extends</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      继承的几种方式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="继承实现方式"><a href="#继承实现方式" class="headerlink" title="继承实现方式"></a>继承实现方式</h2><h3 id="先写一个父类"><a href="#先写一个父类" class="headerlink" title="先写一个父类"></a>先写一个父类</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><pre><code>// 定义一个动物类
function Animal (name) {
  // 属性
  this.name = name || &apos;Animal&apos;;
  this.age = age;
  // 实例方法
  this.sleep = function(){
    console.log(this.name + &apos;正在睡觉！&apos;);
  }
}
// 原型方法
Animal.prototype.eat = function(food) {
  console.log(this.name + &apos;正在吃：&apos; + food);
};
</code></pre><p>###一、原型链继承</p>
<p>####缺点</p>
<pre><code>子类型无法给超类型传递参数；Child.prototype.say要写在Child.prototype = new Parent(&apos;father&apos;)之后，不然会被覆盖掉。
特点：
1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例
2.父类新增原型方法/原型属性，子类都能访问到
3.简单，易于实现
缺点：
1.要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
2.无法实现多继承
3.来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）
4.创建子类实例时，无法向父类构造函数传参
</code></pre><p>#####Demo00</p>
<pre><code>function Cat(){ 
}
Cat.prototype = new Animal();
Cat.prototype.name = &apos;cat&apos;;

//　Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.eat(&apos;fish&apos;));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
</code></pre><p>#####Demo01</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function WangJianlin() &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = [&apos;red&apos;,&apos;orange&apos;,&apos;green&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    WangJianlin.prototype.tv = &apos;豆瓣儿&apos;</span><br><span class="line">    WangJianlin.prototype.money = function () &#123;</span><br><span class="line">        console.log(&apos;给公司YIYIYI投资manymanymany股票了&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function WangSiCong(dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这句话的意思是，将王健林的所有属性挂载到王思聪的原型链上</span><br><span class="line">    WangSiCong.prototype = new WangJianlin();</span><br><span class="line">    //通过原型链继承创建出来的两个网红实例都可以继承不了王健林原型链上的的tv属性和财富方法</span><br><span class="line">    //但是原型的所有方法只能写一次，不能重写(实例指向的是改属性的引用)</span><br><span class="line">    WangSiCong.prototype = new WangJianlin();</span><br><span class="line">    var WangHong1 = new WangSiCong(&apos;keke1&apos;);</span><br><span class="line">    WangHong1.name = &apos;xueying1&apos;</span><br><span class="line">    console.log(WangHong1.name)//undefined</span><br><span class="line">    WangHong1.color.push(&apos;blue&apos;)</span><br><span class="line">    console.log(WangHong1.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">    console.log(WangHong1.tv);//male</span><br><span class="line">    console.log(WangHong1.dog);//keke1</span><br><span class="line">    console.log(WangHong1.money())//给公司YIYIYI投资股票</span><br><span class="line"></span><br><span class="line">    var WangHong2 = new WangSiCong(&apos;keke2&apos;);</span><br><span class="line">    WangHong2.name = &apos;doudeer2&apos;</span><br><span class="line">    console.log(WangHong2.name)//undefined</span><br><span class="line">    console.log(WangHong2.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">    WangHong2.color.push(&apos;gray&apos;)</span><br><span class="line">    console.log(WangHong1.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;gray&quot;]</span><br><span class="line">    console.log(WangHong2.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;gray&quot;]</span><br><span class="line">    console.log(WangHong2.tv);//male</span><br><span class="line">    console.log(WangHong2.dog);//keke1</span><br><span class="line">    console.log(WangHong2.money())//给公司YIYIYI投资股票</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="二、构造函数继承-实例属性继承、伪造对象或经典继承"><a href="#二、构造函数继承-实例属性继承、伪造对象或经典继承" class="headerlink" title="二、构造函数继承(实例属性继承、伪造对象或经典继承)"></a>二、构造函数继承(实例属性继承、伪造对象或经典继承)</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.在构造函数中设置方法会影响性能，多个对象会存储多份function；</span><br><span class="line">无法复用一些公用函数。</span><br><span class="line">2.如果对象比较多，方法比较多，可能会出现命名冲突（函数封装方法）</span><br><span class="line">3.不管有多少对象，原型中的方法在内存中只有一份（重点使用）</span><br><span class="line">  实例对象的原型p1.__proto__ 是非标准的属性，开发中不要使用</span><br><span class="line">4.实例并不是父类的实例，只是子类的实例</span><br><span class="line">5.只能继承父类的实例属性和方法，不能继承原型属性/方法</span><br><span class="line">6.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1.解决了1中，子类实例共享父类引用属性的问题</span><br><span class="line">2.创建子类实例时，可以向父类传递参数</span><br><span class="line">3.可以实现多继承（call多个父类对象）</span><br><span class="line">推荐指数：★★</span><br></pre></td></tr></table></figure>
<h5 id="Demo00"><a href="#Demo00" class="headerlink" title="Demo00"></a>Demo00</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">  Animal.call(this);</span><br><span class="line">  this.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // false</span><br><span class="line">console.log(cat instanceof Cat); // true核心: 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</span><br><span class="line">function Father()&#123;</span><br><span class="line">    this.color = [&quot;red&quot;, &quot;pink&quot;, &quot;yellow&quot;];</span><br><span class="line">&#125;</span><br><span class="line">// 借助call继承</span><br><span class="line">function Son()&#123;</span><br><span class="line">    Father.call(this);</span><br><span class="line">    Father.apply(this);</span><br><span class="line">&#125;</span><br><span class="line">var s1 = new Son();</span><br></pre></td></tr></table></figure>
<h5 id="Demo01"><a href="#Demo01" class="headerlink" title="Demo01"></a>Demo01</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function WangJianlin(name, age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = [&apos;red&apos;,&apos;orange&apos;,&apos;green&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    WangJianlin.prototype.tv = &apos;豆瓣儿&apos;</span><br><span class="line">    WangJianlin.prototype.money = function () &#123;</span><br><span class="line">        console.log(&apos;给公司YIYIYI投资股票&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function WangSiCong( dog) &#123;</span><br><span class="line">        // 这句话的意思是，将王健林的所有属性挂载到王思聪的构造方法上</span><br><span class="line">        WangJianlin.call(this)</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过构造函数继承创建出来的两个网红实例只能继承王健林的基本属性</span><br><span class="line">    // 通过构造函数继承创建出来的两个网红实例都不能继承不了王健林原型链上的的tv属性和财富方法</span><br><span class="line">    var WangHong1 = new WangSiCong( &apos;keke1&apos;);</span><br><span class="line">    WangHong1.name=&apos;xuey&apos;</span><br><span class="line">    WangHong1.color.push(&apos;blue&apos;)</span><br><span class="line">    console.log(WangHong1.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">    console.log(WangHong1.name)//xueying</span><br><span class="line">    console.log(WangHong1.tv);//undefined</span><br><span class="line">    console.log(WangHong1.dog);//keke1</span><br><span class="line">    console.log(WangHong1.money)//undefined</span><br><span class="line"></span><br><span class="line">    var WangHong2 = new WangSiCong(&apos;keke2&apos;);</span><br><span class="line">    WangHong2.name=&apos;doudeer&apos;</span><br><span class="line">    console.log(WangHong2.name)//xueying</span><br><span class="line">    console.log(WangHong2.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;]</span><br><span class="line">    console.log(WangHong2.tv);//undefined</span><br><span class="line">    console.log(WangHong2.dog);//keke1</span><br><span class="line">    console.log(WangHong2.money)//undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="三、组合继承（构造-原型）"><a href="#三、组合继承（构造-原型）" class="headerlink" title="三、组合继承（构造+原型）"></a>三、组合继承（构造+原型）</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">弥补了原型和构造函数的缺点，使用原型链继承原型方法, 使用借用构造函数继承实例属性。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</span><br><span class="line">2.既是子类的实例，也是父类的实例</span><br><span class="line">3.不存在引用属性共享问题</span><br><span class="line">4.可传参</span><br><span class="line">5.函数可复用</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</span><br><span class="line">推荐指数：★★★★（仅仅多消耗了一点内存）</span><br></pre></td></tr></table></figure>
<h5 id="Demo00-1"><a href="#Demo00-1" class="headerlink" title="Demo00"></a>Demo00</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">组合继承也是需要修复构造函数指向的</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">  Animal.call(this);</span><br><span class="line">  this.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>
<h5 id="Demo01-1"><a href="#Demo01-1" class="headerlink" title="Demo01"></a>Demo01</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function WangJianlin() &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = [&apos;red&apos;,&apos;orange&apos;,&apos;green&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    WangJianlin.prototype.tv = &apos;豆瓣儿&apos;</span><br><span class="line">    WangJianlin.prototype.money = function () &#123;</span><br><span class="line">        console.log(&apos;给公司YIYIYI投资more股票&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function WangSiCong(dog) &#123;</span><br><span class="line">        // 这句话的意思是，将王健林的所有属性挂载到王思聪的构造方法上</span><br><span class="line">        WangJianlin.call(this)</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这句话的意思是，将王健林的所有成员挂载到王思聪的原型链上</span><br><span class="line">    WangSiCong.prototype = new WangJianlin();</span><br><span class="line">    var WangHong1 = new WangSiCong(&apos;keke1&apos;);</span><br><span class="line">    WangHong1.name = &apos;xueying&apos;</span><br><span class="line">    console.log(WangHong1.name)//undefined</span><br><span class="line">    WangHong1.color.push(&apos;blue&apos;)//&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">    console.log(WangHong1.color)</span><br><span class="line">    console.log(WangHong1.tv);//male</span><br><span class="line">    console.log(WangHong1.dog);//keke1</span><br><span class="line">    console.log(WangHong1.money())//给公司YIYIYI投资股票</span><br><span class="line">    //两个实例是独立的</span><br><span class="line">    var WangHong2 = new WangSiCong(&apos;keke2&apos;);</span><br><span class="line">    console.log(WangHong2)//&#123;name: &quot;&quot;, color: Array(3), dog: &quot;keke2&quot;&#125;</span><br><span class="line">    WangHong2.name = &apos;doudeer&apos;</span><br><span class="line">    console.log(WangHong2.name)//undefined</span><br><span class="line">    WangHong2.color.push(&apos;black&apos;)</span><br><span class="line">    console.log(WangHong2.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line">    console.log(WangHong2.tv);//male</span><br><span class="line">    console.log(WangHong2.dog);//keke1</span><br><span class="line">    console.log(WangHong2.money())//给公司YIYIYI投资股票</span><br><span class="line">   </span><br><span class="line">    console.log(WangHong2)//WangSiCong &#123;name: &quot;doudeer&quot;, color: Array(4), dog: &quot;keke2&quot;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Demo01优化方式一"><a href="#Demo01优化方式一" class="headerlink" title="Demo01优化方式一"></a>Demo01优化方式一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 直接把父类的原型对象赋给子类的原型对象</span><br><span class="line">      function WangJianlin() &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = [&apos;red&apos;,&apos;orange&apos;,&apos;green&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    WangJianlin.prototype.tv = &apos;豆瓣儿&apos;</span><br><span class="line">    WangJianlin.prototype.money = function () &#123;</span><br><span class="line">        console.log(&apos;给公司YIYIYI投资more股票&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function WangSiCong(dog) &#123;</span><br><span class="line">        // 这句话的意思是，将王健林的所有属性挂载到王思聪的构造方法上</span><br><span class="line">        WangJianlin.call(this)</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这句话的意思是，将王健林的所有成员挂载到王思聪的原型链上</span><br><span class="line">    WangSiCong.prototype = WangJianlin.prototype;</span><br><span class="line">    var WangHong1 = new WangSiCong(&apos;keke1&apos;);</span><br><span class="line">    WangHong1.name = &apos;xueying&apos;</span><br><span class="line">    console.log(WangHong1.name)//undefined</span><br><span class="line">    WangHong1.color.push(&apos;blue&apos;)//&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">    console.log(WangHong1.color)</span><br><span class="line">    console.log(WangHong1.tv);//male</span><br><span class="line">    console.log(WangHong1.dog);//keke1</span><br><span class="line">    console.log(WangHong1.money())//给公司YIYIYI投资股票</span><br><span class="line">    //两个实例是独立的</span><br><span class="line">    var WangHong2 = new WangSiCong(&apos;keke2&apos;);</span><br><span class="line">    WangHong2.name = &apos;doudeer&apos;</span><br><span class="line">    console.log(WangHong2.name)//undefined</span><br><span class="line">    WangHong2.color.push(&apos;black&apos;)</span><br><span class="line">    console.log(WangHong2.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line">    console.log(WangHong2.tv);//male</span><br><span class="line">    console.log(WangHong2.dog);//keke1</span><br><span class="line">    console.log(WangHong2.money())//给公司YIYIYI投资股票</span><br><span class="line">    // 缺点：父类的构造函数被执行了两次</span><br><span class="line">    // 第一次：WangSiCong.prototype = new WangJianlin();</span><br><span class="line">    // 第二次：实例化的时候（ WangHong1、 WangHong2）</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Demo01优化方式二"><a href="#Demo01优化方式二" class="headerlink" title="Demo01优化方式二"></a>Demo01优化方式二</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 堪称继承最完美的方式！！！ --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function WangJianlin() &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = [&apos;red&apos;, &apos;orange&apos;, &apos;green&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    WangJianlin.prototype.tv = &apos;豆瓣儿&apos;</span><br><span class="line">    WangJianlin.prototype.money = function () &#123;</span><br><span class="line">        console.log(&apos;给公司YIYIYI投资more股票&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    function WangSiCong(dog) &#123;</span><br><span class="line">        // 这句话的意思是，将王健林的所有属性挂载到王思聪的构造方法上</span><br><span class="line">        WangJianlin.call(this)</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这句话的意思是，将王健林的所有成员挂载到王思聪的原型链上</span><br><span class="line">    WangSiCong.prototype = Object.create(WangJianlin.prototype)</span><br><span class="line">    WangSiCong.prototype.constructor = WangSiCong</span><br><span class="line">    var WangHong1 = new WangSiCong(&apos;keke1&apos;);</span><br><span class="line">    WangHong1.name = &apos;xueying&apos;</span><br><span class="line">    console.log(WangHong1.name)//undefined</span><br><span class="line">    WangHong1.color.push(&apos;blue&apos;)//&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">    console.log(WangHong1.color)</span><br><span class="line">    console.log(WangHong1.tv);//male</span><br><span class="line">    console.log(WangHong1.dog);//keke1</span><br><span class="line">    console.log(WangHong1.money())//给公司YIYIYI投资股票</span><br><span class="line">    //两个实例是独立的</span><br><span class="line">    var WangHong2 = new WangSiCong(&apos;keke2&apos;);</span><br><span class="line">    WangHong2.name = &apos;doudeer&apos;</span><br><span class="line">    console.log(WangHong2.name)//undefined</span><br><span class="line">    WangHong2.color.push(&apos;black&apos;)</span><br><span class="line">    console.log(WangHong2.color)//[&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line">    console.log(WangHong2.tv);//male</span><br><span class="line">    console.log(WangHong2.dog);//keke1</span><br><span class="line">    console.log(WangHong2.money())//给公司YIYIYI投资股票</span><br><span class="line">    // 缺点：父类的构造函数被执行了两次</span><br><span class="line">    // 第一次：WangSiCong.prototype = new WangJianlin();</span><br><span class="line">    // 第二次：实例化的时候（ WangHong1、 WangHong2）</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="四、copy继承（深、浅）"><a href="#四、copy继承（深、浅）" class="headerlink" title="四、copy继承（深、浅）"></a>四、copy继承（深、浅）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">深copy(所有成员（属性、方法）)、浅copy（属性）</span><br><span class="line">深拷贝，如果对象的成员是复杂类型，会把复杂类型的对象也拷贝一份</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">支持多继承</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1.效率较低，内存占用高（因为要拷贝父类的属性）</span><br><span class="line">2.无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</span><br><span class="line">推荐指数：★（缺点1）</span><br></pre></td></tr></table></figure>
<h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">  var animal = new Animal();</span><br><span class="line">  for(var p in animal)&#123;</span><br><span class="line">    Cat.prototype[p] = animal[p];</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // false</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>
<h5 id="Demo01（浅拷贝）"><a href="#Demo01（浅拷贝）" class="headerlink" title="Demo01（浅拷贝）"></a>Demo01（浅拷贝）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 浅拷贝（只会把父级最外层的成员继承过来，而子级与父级内层的对象会指向同一个引用）</span><br><span class="line">    // 专业滴说，如果对象的成员是复杂类型，不会把复杂类型的对象拷贝一份，会公用父级的复杂对象</span><br><span class="line">    function shadowCopy(parent, child) &#123;</span><br><span class="line">      for (var key in parent) &#123;</span><br><span class="line">        if (!child[key]) &#123;</span><br><span class="line">          child[key] = parent[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var wjl = &#123;</span><br><span class="line">      name: &apos;王健林&apos;,</span><br><span class="line">      money: 100000,</span><br><span class="line">      cars: [&apos;五菱宏光&apos;, &apos;玛莎拉蒂&apos;],</span><br><span class="line">      dog: &#123;</span><br><span class="line">        name: &apos;BYD&apos;,</span><br><span class="line">        age: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var wsc = &#123;</span><br><span class="line">      name: &apos;王思聪&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shadowCopy(wjl, wsc);</span><br><span class="line"></span><br><span class="line">    wsc.dog.name = &apos;wkk&apos;;</span><br><span class="line">    wsc.money = 1;</span><br><span class="line">    console.log(wsc);</span><br><span class="line">    console.log(wjl);</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Demo02（深拷贝）"><a href="#Demo02（深拷贝）" class="headerlink" title="Demo02（深拷贝）"></a>Demo02（深拷贝）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 深拷贝，如果对象的成员是复杂类型，会把复杂类型的对象也拷贝一份</span><br><span class="line"></span><br><span class="line">    function deepCopy(parent, child) &#123;</span><br><span class="line">      for (var key in parent) &#123;</span><br><span class="line">        // 判断child中是否有对应的属性</span><br><span class="line">        if (child[key]) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断parent[key] 对象的类型 是数组还是对象</span><br><span class="line">        // instanceof</span><br><span class="line">        // 先判断数组  ，因为数组也是对象</span><br><span class="line">        if (parent[key] instanceof Function) &#123;</span><br><span class="line">          child[key] = parent[key];</span><br><span class="line">        &#125; else if (parent[key] instanceof Array) &#123;</span><br><span class="line">          child[key] = [];</span><br><span class="line">          // 把parent[key] 数组 中所有的成员拷贝给child[key]</span><br><span class="line">          deepCopy(parent[key], child[key]);</span><br><span class="line">        &#125; else if (parent[key] instanceof Object) &#123;</span><br><span class="line">          child[key] = &#123;&#125;;</span><br><span class="line">          // 把parent[key] 对象 中所有的成员拷贝给child[key]</span><br><span class="line">          deepCopy(parent[key], child[key]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 拷贝基本类型的属性</span><br><span class="line">          child[key] = parent[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var wjl = &#123;</span><br><span class="line">      name: &apos;王健林&apos;,</span><br><span class="line">      money: 100000,</span><br><span class="line">      cars: [&apos;五菱宏光&apos;, &apos;玛莎拉蒂&apos;],</span><br><span class="line">      dog: &#123;</span><br><span class="line">        name: &apos;BYD&apos;,</span><br><span class="line">        age: 2</span><br><span class="line">      &#125;,</span><br><span class="line">      play: function () &#123;</span><br><span class="line">        console.log(&apos;打高尔夫&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var wsc = &#123;</span><br><span class="line">      name: &apos;王思聪&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deepCopy(wjl, wsc);</span><br><span class="line">    </span><br><span class="line">    wsc.dog.name = &apos;wangkeke&apos;;</span><br><span class="line"></span><br><span class="line">    console.log(wsc);</span><br><span class="line">    console.log(wjl);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">  var animal = new Animal();</span><br><span class="line">  for(var p in animal)&#123;</span><br><span class="line">    Cat.prototype[p] = animal[p];</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // false</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>
<h3 id="五、ES6继承extends"><a href="#五、ES6继承extends" class="headerlink" title="五、ES6继承extends"></a>五、ES6继承extends</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends</span><br></pre></td></tr></table></figure>
<h5 id="Demo01-2"><a href="#Demo01-2" class="headerlink" title="Demo01"></a>Demo01</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    class WangJanLin &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    class WangSiCong extends WangJanLin &#123;</span><br><span class="line">        //这句话的意思是，调用父类的constructor</span><br><span class="line">        // ES5在这写，必须定义constructor</span><br><span class="line">        constructor(x, y, colors) &#123;</span><br><span class="line">            super(x, y)</span><br><span class="line">            this.colors = colors</span><br><span class="line">        &#125;</span><br><span class="line">        // 给子类定义一个方法</span><br><span class="line">        toString() &#123;</span><br><span class="line">            return this.colors + &apos;&apos; + super.toString();//调用父类发tostring</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var WangHong1 = new WangSiCong(&apos;颜色1&apos;, &apos;颜色2&apos;, [&apos;red&apos;, &apos;orange&apos;, &apos;green&apos;])</span><br><span class="line">    console.log(WangHong1.colors)</span><br><span class="line">    console.log(WangHong1.toString())</span><br><span class="line"></span><br><span class="line">    var WangHong2 = new WangSiCong(&apos;&apos;, &apos;&apos;, [&apos;red&apos;, &apos;orange&apos;, &apos;green&apos;, &apos;blue&apos;])</span><br><span class="line">    console.log(WangHong2.colors)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="六、寄生式继承"><a href="#六、寄生式继承" class="headerlink" title="六、寄生式继承"></a>六、寄生式继承</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">堪称完美</span><br><span class="line">缺点：</span><br><span class="line">实现较为复杂</span><br><span class="line">推荐指数：★★★★（实现复杂，扣掉一颗星）</span><br></pre></td></tr></table></figure>
<h5 id="Demo00-Object-create式"><a href="#Demo00-Object-create式" class="headerlink" title="Demo00(Object.create式)"></a>Demo00(Object.create式)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">  Animal.call(this);</span><br><span class="line">  this.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">  // 创建一个没有实例方法的类(新类/第三方类)</span><br><span class="line">  var Super = function()&#123;&#125;;</span><br><span class="line">  Super.prototype = Animal.prototype;</span><br><span class="line">  //将实例作为子类的原型</span><br><span class="line">  Cat.prototype = new Super();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); //true</span><br><span class="line"></span><br><span class="line">Cat.prototype.constructor = Cat; // 需要修复下构造函数</span><br></pre></td></tr></table></figure>
<h5 id="Demo寄生组合式"><a href="#Demo寄生组合式" class="headerlink" title="Demo寄生组合式"></a>Demo寄生组合式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">优点：解决了两次调用的问题</span><br><span class="line">  // 创建只继承原型对象的函数</span><br><span class="line">    function inheritPrototype(parent, child) &#123;</span><br><span class="line">       // 创建一个原型对象副本-创建对象</span><br><span class="line">       var prototype = new Object(parent.prototype);</span><br><span class="line">       // 设置constructor属性-增强对象</span><br><span class="line">       prototype.constructor = child;</span><br><span class="line"> 	   //指定对象</span><br><span class="line">       child.prototype = prototype;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">     // 父亲类</span><br><span class="line">     function Parent() &#123;</span><br><span class="line">         this.color = [&apos;pink&apos;, &apos;red&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">     Parent.prototype.sayHi = function() &#123;</span><br><span class="line">        console.log(&apos;Hi&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 儿子类</span><br><span class="line">     function Child() &#123;</span><br><span class="line">         Parent.call(this);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">    inheritPrototype(Parent, Child);</span><br></pre></td></tr></table></figure>
<p>###七、原型式继承</p>
<p>####思想</p>
<pre><code>// 基于已有的对象创建对象
</code></pre><p>#####Demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(o) &#123;</span><br><span class="line">     // 创建一个临时构造函数</span><br><span class="line">     function F() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     // 将传入的对象作为它的原型</span><br><span class="line">    F.prototype = o;</span><br><span class="line">     // 返回一个实例</span><br><span class="line">       return new F();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="附录Demo00"><a href="#附录Demo00" class="headerlink" title="附录Demo00"></a>附录Demo00</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Animal (name) &#123;</span><br><span class="line">  // 属性</span><br><span class="line">  this.name = name || &apos;Animal&apos;;</span><br><span class="line">  // 实例方法</span><br><span class="line">  this.sleep = function()&#123;</span><br><span class="line">    console.log(this.name + &apos;正在睡觉！&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  //实例引用属性</span><br><span class="line">  this.features = [];</span><br><span class="line">&#125;</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">var tom = new Cat(&apos;Tom&apos;);</span><br><span class="line">var kissy = new Cat(&apos;Kissy&apos;);</span><br><span class="line"></span><br><span class="line">console.log(tom.name); // &quot;Animal&quot;</span><br><span class="line">console.log(kissy.name); // &quot;Animal&quot;</span><br><span class="line">console.log(tom.features); // []</span><br><span class="line">console.log(kissy.features); // []</span><br><span class="line"></span><br><span class="line">tom.name = &apos;Tom-New Name&apos;;</span><br><span class="line">tom.features.push(&apos;eat&apos;);</span><br><span class="line"></span><br><span class="line">//针对父类实例值类型成员的更改，不影响</span><br><span class="line">console.log(tom.name); // &quot;Tom-New Name&quot;</span><br><span class="line">console.log(kissy.name); // &quot;Animal&quot;</span><br><span class="line">//针对父类实例引用类型成员的更改，会通过影响其他子类实例</span><br><span class="line">console.log(tom.features); // [&apos;eat&apos;]</span><br><span class="line">console.log(kissy.features); // [&apos;eat&apos;]</span><br><span class="line"></span><br><span class="line">原因分析：</span><br><span class="line">关键点：属性查找过程</span><br><span class="line">执行tom.features.push，首先找tom对象的实例属性（找不到），</span><br><span class="line">那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的</span><br><span class="line">features属性中插入值。</span><br><span class="line">在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。</span><br><span class="line">刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/JS继承的几种方式/" data-id="cjt6p7ptv000t64fy3b30a6ra" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/继承/">继承</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/13/ajax-前后数据交互-页面渲染-跨域/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Ajax模与前后台数据交互与页面渲染与跨域
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/">ajax</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/数据交互/">数据交互</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/数据交互/跨域/">跨域</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/数据交互/跨域/模板引擎/">模板引擎</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ajax/数据交互/跨域/模板引擎/前台渲染/">前台渲染</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/构造函数继承/">构造函数继承</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/构造函数继承/原型继承/">原型继承</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/构造函数继承/原型继承/构造-原型继承/">构造+原型继承</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/构造函数继承/原型继承/构造-原型继承/copy/">copy</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/构造函数继承/原型继承/构造-原型继承/copy/extends/">extends</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目开发思想/">项目开发思想</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发思想/">开发思想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/继承/">继承</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/开发思想/" style="font-size: 10px;">开发思想</a> <a href="/tags/继承/" style="font-size: 10px;">继承</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/13/搭建个人博客/">hexo 搭建个人博客</a>
          </li>
        
          <li>
            <a href="/2019/03/13/mvc/">MVC与MVVM之间的区别</a>
          </li>
        
          <li>
            <a href="/2019/03/13/博客书写模板/">博客md书写模板</a>
          </li>
        
          <li>
            <a href="/2019/03/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/03/13/ajax-前后数据交互-页面渲染-跨域/">Ajax模与前后台数据交互与页面渲染与跨域</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>